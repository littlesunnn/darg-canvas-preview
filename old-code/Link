import { AlignType, CtrlType, Events, LinkMark, LinkMethod, LinkStyle } from "../../../Constants";
import { IPoint, IRecordProps, IRelativePos, IVctor } from "../../../Interface";
import { Utils } from "../../../utils";
import Feature from "../../Feature";
import Line from "../Line";
import { getPolylinePoints } from "./edge";

// 连接线
export default class Link extends Line {

    private _isSettingAnchor = false;
    _startFeature: Feature | null = null;   // 如果你要设置为点坐标,你可以通过setTarget去更新link
    get startFeature() { return this._startFeature }
    set startFeature(val) {
        this._startFeature = val;
        if (val) this.setTarget(val, LinkMark.START)
    }
    _endFeature: Feature | null = null;
    get endFeature() { return this._endFeature }
    set endFeature(val) {
        this._endFeature = val;
        if (val) this.setTarget(val, LinkMark.START)
    }
    _lastAnchor = LinkMethod.CENTER // 没有锚点时候设置锚点位置方式
    _lastLinkStyle = LinkStyle.DEFAULT;
    _setAnchor = () => this.setAnchor()

    // 如果是传的是点,那么可能无法通过拖拽更新link的位置
    constructor(startFeature: Feature | IRelativePos = { x: 0, y: 0 }, endFeature: Feature | IRelativePos = { x: 0, y: 0 }) {
        let startPos: IRelativePos = { x: 0, y: 0 };
        let endPos: IRelativePos = { x: 0, y: 0 };
        // 是Feature元素则获取元素的中心点
        startFeature instanceof Feature ? startPos = startFeature.getCenterPos() : startPos = startFeature as IRelativePos;
        endFeature instanceof Feature ? endPos = endFeature.getCenterPos() : endPos = endFeature as IRelativePos;
        super([startPos, endPos]);
        this.strokeStyle = "#000";
        this.zIndex = -Infinity;
        this.cbTranslate = false;
        this.cbTransform = false;  // 设置为false,会自动计算线段样式
        this.ctrlTypes = [CtrlType.BEZIER_CTRL];  // 可用的控制点类型有哪些
        this.initEventListener(startFeature, endFeature)
    }

    initEventListener(startFeature: Feature | IRelativePos, endFeature: Feature | IRelativePos) {
        this.setTarget(startFeature, LinkMark.START)
        this.setTarget(endFeature, LinkMark.END)
    }
    // 设置link的连接锚点,比如就是元素的中心点,又或是元素的上下左右,又或是两元素距离最新的点
    setAnchor(anchor = this._lastAnchor) {
        if (this._isSettingAnchor) return;  // 防止死循环
        this._isSettingAnchor = true;
        try {
            const sf = this.startFeature;
            const ef = this.endFeature;
            let sp = this.pointArr[0];
            let ep = this.pointArr[this.pointArr.length - 1];
            switch (anchor) {
                case LinkMethod.CENTER: {
                    if (sf && sf instanceof Feature) {
                        sp = sf.getCenterPos();
                    } else if (sf) {
                        sp = sf;
                    }
                    if (ef && ef instanceof Feature) {
                        ep = ef.getCenterPos();
                    } else if (ef) {
                        ep = ef;
                    }
                    this.pointArr = [sp, ep]
                    break;
                }
                case LinkMethod.CLOSEST: {
                    if (sf && ef) {
                        this.pointArr = [...Utils.getTwoPointOfClosest(sf?.pointArr || [sf], ef?.pointArr || [ef])];
                        break;
                    }
                    break;
                }
                case LinkMethod.AUTOEDGE: {
                    if (sf && sf instanceof Feature) {
                        sp = sf.getCenterPos();
                    } else if (sf) {
                        sp = sf;
                    }
                    if (ef && ef instanceof Feature) {
                        ep = ef.getCenterPos();
                    } else if (ef) {
                        ep = ef;
                    }
                    const direction = Utils.determinePosition(sp, ep);
                    const [nsp, nep] = this.getLinkPosByDirection(direction, this.startFeature || sp, this.endFeature || ep)
                    this.pointArr = [nsp, nep];
                    break;
                }
                case LinkMethod.EDGE: {
                    if (sf && sf instanceof Feature) {
                        sp = sf.getCrossBboxPoints()[sf.edgeAlign || AlignType.TOP];
                    } else if (sf) {
                        sp = sf;
                    }
                    if (ef && ef instanceof Feature) {
                        ep = ef.getCrossBboxPoints()[ef.edgeAlign || AlignType.TOP];
                    } else if (ef) {
                        ep = ef;
                    }
                    this.pointArr = [sp, ep];
                    break;
                }
                default:
                    this.pointArr = [sp, ep];
                    break;
            }
            this._lastAnchor = anchor;
            this.setShape();  // 要在setAnchor之后设置,否则trigger.pointArr 始终是2个点
            if (this.startFeature instanceof Feature) {
                this.startFeature.dispatch(new CustomEvent(Events.LINK_UPDATE, {
                    detail: {
                        trigger: this,
                        type: LinkMark.START,
                        target: this.startFeature,
                    }
                }))
            }
            if (this.endFeature instanceof Feature) {
                this.endFeature.dispatch(new CustomEvent(Events.LINK_UPDATE, {
                    detail: {
                        trigger: this,
                        type: LinkMark.END,
                        target: this.endFeature,
                    }
                }))
            }
            document.dispatchEvent(new CustomEvent(Events.RENDER, { detail: { target: this } }));
        } finally {
            this._isSettingAnchor = false;
        }
    }
    // 设置连接样式
    setLineStyle(linkStyle: LinkStyle = this._lastLinkStyle, ...args: any) {
        const getGeneratePointArrFn = this.getGeneratePointArrFn;
        switch (linkStyle) {
            case LinkStyle.CURVE2_HORIZINAL:
                this.getGeneratePointArrFn = this.getBezier2CurvePoints;
                break;
            case LinkStyle.CURVE2_VERTIVAL:
                this.getGeneratePointArrFn = () => this.getBezier2CurvePoints(this.pointArr, AlignType.VERTICAL);
                break;
            case LinkStyle.CURVE3_HORIZINAL:
                this.getGeneratePointArrFn = this.getBezier3CurvePoints;
                break;
            case LinkStyle.CURVE3_VETIVAL:
                this.getGeneratePointArrFn = () => this.getBezier3CurvePoints(this.pointArr, AlignType.VERTICAL);
                break;
            case LinkStyle.BROKEN2:
                this.getGeneratePointArrFn = this.getBroken2Points;
                break;
            case LinkStyle.BROKEN1:
                this.getGeneratePointArrFn = this.getBrokenPoints;
                break;
            case LinkStyle.AUTO_FIND:
                this.getGeneratePointArrFn = () => this.getAutoFindPoints(...args);
                break;
            default:
                this.getGeneratePointArrFn = null;
                break;
        }
        this._lastLinkStyle = linkStyle;
        if (getGeneratePointArrFn != this.getGeneratePointArrFn) this.bezierCtrlPnts = [];
        this.setAnchor();
    }
    // 设置起点或终点的元素,可以是元素,也可以是静态的坐标   
    setTarget(feature: Feature | IRelativePos, type: LinkMark = LinkMark.END) {
        if (!feature) return;
        switch (type) {
            case LinkMark.START: {
                if (this.startFeature instanceof Feature) this.startFeature?.off(Events.DRAW, this._setAnchor)
                this.startFeature = null;
                if (feature instanceof Feature) {
                    this._startFeature = feature;
                    feature.on(Events.DRAW, this._setAnchor)
                } else if (feature.x && feature.y) {
                    this.pointArr[0] = feature;
                }
                break;
            }
            case LinkMark.END: {
                if (this.endFeature instanceof Feature) this.endFeature?.off(Events.DRAW, this._setAnchor)
                this.endFeature = null;
                if (feature instanceof Feature) {
                    this._endFeature = feature;
                    feature.on(Events.DRAW, this._setAnchor)
                } else if (feature.x && feature.y) {
                    this.pointArr[this.pointArr.length - 1] = feature;
                }
                break;
            }
            default:
                break;
        }
        this.setAnchor();
    }
    // 2次贝塞尔曲线样式计算点
    getBezier2CurvePoints(pointArr: IPoint[] = this.pointArr, type: AlignType = AlignType.HORIZONTAL, ctrlExtent = 1.5, pntsLimit = 50): IPoint[] {
        let vct: IVctor, cp1: IPoint;
        const startPos = pointArr[0]
        const endPos = pointArr[pointArr.length - 1]
        if (this.bezierCtrlPnts.length && this.cbTransform) {
            cp1 = this.bezierCtrlPnts[0]!;
        } else {
            const lineVct = Utils.getVector(startPos, endPos);
            switch (type) {
                default:
                case AlignType.HORIZONTAL: {
                    vct = Utils.getRotateVct(lineVct, 90);
                    cp1 = Utils.getPntInVct(Utils.getMidOfTwoPnts(startPos, endPos), vct, (startPos.y - endPos.y) / ctrlExtent);
                    break;
                }
                case AlignType.VERTICAL: {
                    vct = Utils.getRotateVct(lineVct, -90);
                    cp1 = Utils.getPntInVct(Utils.getMidOfTwoPnts(startPos, endPos), vct, (startPos.x - endPos.x) / ctrlExtent);
                }
                    break;
            }
            this.bezierCtrlPnts[0] = cp1;
        }
        const points = Utils.getPntsOf2Bezier(startPos, cp1, endPos, pntsLimit).map((p, j) => ({ x: p.x, y: p.y, generated: j != 0 })) as IPoint[];
        points.push(endPos);
        return points;
    }
    // 3次贝塞尔曲线样式计算点
    getBezier3CurvePoints(pointArr: IPoint[] = this.pointArr, type: AlignType = AlignType.HORIZONTAL, ctrlExtent = 1.5, pntsLimit = 50): IPoint[] {
        let vct: IVctor, cp1: IPoint, cp2: IPoint;
        const startPos = pointArr[0]
        const endPos = pointArr[pointArr.length - 1]
        if (this.bezierCtrlPnts.length && this.cbTransform) {
            cp1 = this.bezierCtrlPnts[0]!;
            cp2 = this.bezierCtrlPnts[1]!;
        } else {
            // if(this._lastAnchor === LinkMethod.EDGE){
            //     this.startFeature?.edgeAlign
            //     switch (this.startFeature?.edgeAlign) {
            //         case AlignType.TOP:
            //             vct = [0, -1] as IVctor;
            //             const cp1 =

            //             break;

            //         default:
            //             break;
            //     }
            //     // const startEdge = this.startFeature?.getCrossBboxPoints()[this.startFeature?.edgeAlign || AlignType.TOP];
            // }
            switch (type) {
                default:
                case AlignType.VERTICAL: {
                    vct = [0, -1] as IVctor;
                    cp1 = Utils.getPntInVct(startPos, vct, (startPos.y - endPos.y) / ctrlExtent);
                    cp2 = Utils.getPntInVct(endPos, vct, (endPos.y - startPos.y) / ctrlExtent);
                    break;
                }
                case AlignType.HORIZONTAL: {
                    vct = [-1, 0] as IVctor;
                    cp1 = Utils.getPntInVct(startPos, vct, (startPos.x - endPos.x) / ctrlExtent);
                    cp2 = Utils.getPntInVct(endPos, vct, (endPos.x - startPos.x) / ctrlExtent);
                }
                    break;
            }
            this.bezierCtrlPnts[0] = cp1;
            this.bezierCtrlPnts[1] = cp2;
        }
        const points = Utils.getPntsOf3Bezier(startPos, cp1, cp2, endPos, pntsLimit).map((p, j) => ({ x: p.x, y: p.y, generated: j != 0 })) as IPoint[];
        points.push(endPos);
        return points;
    }
    // 2段折线
    getBroken2Points(pointArr: IPoint[] = this.pointArr, type: AlignType = AlignType.HORIZONTAL, ctrlExtent = .5): IPoint[] {
        let cp1: IPoint, cp2: IPoint;
        const startPos = pointArr[0]
        const endPos = pointArr[pointArr.length - 1]
        const mid = Utils.getPointOnSegment(startPos, endPos, ctrlExtent)
        if (this.bezierCtrlPnts.length && this.cbTransform) {
            cp1 = this.bezierCtrlPnts[0]!;
            cp2 = this.bezierCtrlPnts[1]!;
        } else {
            if (type === AlignType.VERTICAL) {
                cp1 = { x: mid.x, y: startPos.y, generated: true };
                cp2 = { x: mid.x, y: endPos.y, generated: true };
            } else {
                cp1 = { x: startPos.x, y: mid.y, generated: true };
                cp2 = { x: endPos.x, y: mid.y, generated: true };
            }
            this.bezierCtrlPnts[0] = cp1;
            this.bezierCtrlPnts[1] = cp2;
        }
        return [startPos, cp1, cp2, endPos];
    }
    // 1段折线
    getBrokenPoints(pointArr: IPoint[] = this.pointArr, type: AlignType = AlignType.HORIZONTAL): IPoint[] {
        let cp1: IPoint;
        const startPos = pointArr[0]
        const endPos = pointArr[pointArr.length - 1]
        if (this.bezierCtrlPnts.length && this.cbTransform) {
            cp1 = this.bezierCtrlPnts[0]!;
        } else {
            if (type === AlignType.VERTICAL) {
                cp1 = { x: endPos.x, y: startPos.y, generated: true };
            } else {
                cp1 = { x: startPos.x, y: endPos.y, generated: true };
            }
            this.bezierCtrlPnts[0] = cp1;
        }
        return [startPos, cp1, endPos];
    }
    // 自动寻路样式
    getAutoFindPoints(pointArr: IPoint[] = this.pointArr, padding = 10, cbRotate = true) {  // 自动寻路  
        let startPos = pointArr[0]
        let endPos = pointArr[pointArr.length - 1]
        if (this.startFeature instanceof Feature && this.endFeature instanceof Feature) {
            const rectBoxInfo = this.startFeature.getBboxInfo();
            const circleBoxInfo = this.endFeature.getBboxInfo();
            if (cbRotate) {
                startPos = Utils.getRotatePnt(rectBoxInfo, startPos, this.startFeature.angle)
                endPos = Utils.getRotatePnt(circleBoxInfo, endPos, this.endFeature.angle)
            }
            const routes = getPolylinePoints(
                startPos,
                endPos,
                this.startFeature,
                this.endFeature,
                padding,
            );
            return routes;
        } else {
            throw '目标元素必须是元素类型'
        }
    }
    // 获取元素的上下左右那个点作为锚点
    getLinkPosByDirection(direction: AlignType, start: Feature | IPoint, end: Feature | IPoint): IRelativePos[] {
        const sPointArr = start instanceof Feature ? start.pointArr : [start];
        const ePointArr = end instanceof Feature ? end.pointArr : [end];
        const startEdges = this.getBboxEdges(sPointArr) as IPoint[][];
        const endEdges = this.getBboxEdges(ePointArr) as IPoint[][];
        switch (direction) {
            case AlignType.TOP: {
                const startP = Utils.getMidOfTwoPnts(startEdges[0][0], startEdges[0][1])
                const endP = Utils.getMidOfTwoPnts(endEdges[2][0], endEdges[2][1])
                return [startP, endP];
            }
            case AlignType.RIGHT: {
                const startP = Utils.getMidOfTwoPnts(startEdges[1][0], startEdges[1][1])
                const endP = Utils.getMidOfTwoPnts(endEdges[3][0], endEdges[3][1])
                return [startP, endP];
            }
            case AlignType.BOTTOM: {
                const startP = Utils.getMidOfTwoPnts(startEdges[2][0], startEdges[2][1])
                const endP = Utils.getMidOfTwoPnts(endEdges[0][0], endEdges[0][1])
                return [startP, endP];
            }
            case AlignType.LEFT: {
                const startP = Utils.getMidOfTwoPnts(startEdges[3][0], startEdges[3][1])
                const endP = Utils.getMidOfTwoPnts(endEdges[1][0], endEdges[1][1])
                return [startP, endP];
            }
            default:
                return [{ x: 0, y: 0 }, { x: 0, y: 0 }];
        }
    }

    clone(props: IRecordProps = this.getJson()) {
        const shallowCopy = super.clone(props);
        shallowCopy.initEventListener();
        return shallowCopy
    }

    getJson() {
        const json = super.getJson();
        return {
            ...json,
            _lastAnchor: this._lastAnchor,
            _lastLinkStyle: this._lastLinkStyle,
            _startFeature: this.startFeature instanceof Feature ? this.startFeature.id : this.startFeature,
            _endFeature: this.endFeature instanceof Feature ? this.endFeature.id : this.endFeature,
        }
    }

    override destroy() {
        this.startFeature?.off(Events.DRAW, this._setAnchor)
        this.endFeature?.off(Events.DRAW, this._setAnchor)
        super.destroy();
    }
}